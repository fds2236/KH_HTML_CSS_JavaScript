// 함수
// 1. 특정 작업을 여러 번 반복 수행해야하는 경우 재사용 목적으로 만듦
// 2. 특정 이벤트 발생 시 기능을 동작하게 할 수 있음
// 3. 함수를 먼저 호출하고 나중에 선언해도 동작0, 함수끌어올림(호이스팅)
// 4. 함수 선언만으로 동작하지 않음(함수 호출이 반드시 있어야 함)
// 보통 버튼에 함수 걸려면 js에서 함수선언하고 html에서 함수 호출함
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 자바스크립트는 같은 변수명으로 선언시 var 중복 선언 가능, let 중복 선언 불가
// var number1 = 10;
// var number1 = 20; // var는 에러 안남
// let number2 = 10;
// let number2 = 20; // let은 에러
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 함수 호출
// let sum1 = sum(100, 200);
// console.log(sum1);

// 함수 선언
// sum(100, 200)
// function sum(n1, n2) {
//     return n1 + n2;
// }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 함수 선언식과 함수 표현식 구분해야함!
//함수 선언식 : 함수를 선언하고 호출을 아무 곳에서나 호출할 수 있음(끌어올림 가능)
// sum(100, 200);
// function sum(p1, p2) {
//     return p1 + p2;
// }

// 함수 표현식 : 변수에 함수를 할당해서 사용하는 방식(끌어올림 불가), 익명의 함수(함수이름 없음)
// sum(100, 200);
// let sum = function(p1, p2) {
//     return p1 + p2;
// }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// let firstVal;
// let secondVal;
// let op;
// function inputFst(num) {
//     firstVal = num;
// }
// function inputSec(num) {
//     secondVal = num;
// }
// function inputOp(operator) {
//     op = operator;
// }
// function inputEnter() {
//     switch(op) {
//         case "+" :
//             document.write("<h1>" + (firstVal + secondVal) + "</h1>");
//             break;
//         case "-" :
//             document.write("<h1>" + (firstVal - secondVal) + "</h1>");
//             break;
//         case "*" :
//             document.write("<h1>" + (firstVal * secondVal) + "</h1>");
//             break;
//         case "/" :
//             document.write("<h1>" + (firstVal / secondVal) + "</h1>");
//             break;
//         default : 
//     }
// }
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// const gugudan = function() {
//     for(let i = 1; i < 10; i++) {
//         console.log(`3 * ${i} = ${3 * i}`);
//     }
// }
// let test = gugudan; // 주소를 복사
// test();

// 함수표현식
const gugudan1 = function(dan) {
    for (let i = 1; i < 10; i++) {
        console.log(`${dan} * ${i} = ${dan * i}`);
    }
}

// 화살표함수
const gugudan2 = (dan) => {
    for (let i = 1; i < 10; i++) {
        console.log(`${dan} * ${i} = ${dan * i}`);
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* 함수 및 변수의 스코프 이해 */
// 블록 스코프 방식 : ES6부터 추가된 개념 let, const(끌어올림 안함), 블록내부에서만 존재
// 함수 스코프 방식 : 함수에서 정의한 블록문만 스코프 유효 범위로 간주, var(맨 위로 끌어올림 함)
// 즉시 실행 함수 : ???
// Callback 함수 : 함수의 내부에서 실행하는 함수


// 궁금한 점 let은 중복해서 변수선언 불가능한데 왜 a 두 번 썼는데 오류 안나지??
// 또 const로 변수선언하면 대입한 값을 바꿀 수 없는데 왜 바꿀 수 있지?
// 블록 스코프 방식 : let, const 
// 블록 스코프방식을 쓰면 재정의가 가능함(영역이 다르다고 생각하면 됨!)
// const a = 10; // 전역변수
// {   const a = 100; // 지역변수, 전역변수보다 지역변수가 우선
//     let b = 20; // 지역변수
//     console.log(`코드 블록 내부 a : ${a}`); // 출력 : 100
//     console.log(`코드 블록 내부 b : ${b}`); // 출력 : 20
// }
// console.log(`코드 블록 외부 a : ${a}`); // 출력 : 10
// console.log(`코드 블록 외부 b : ${b}`); // 출력 오류, let b를 var b로 바꾸면 가능!


// 함수 스코프 방식 : var
// 먄약 let b를 var b로 바꾸면 코드 블록 외부 b값 출력됨
// 왜? var는 호이스팅함(끌어올림됨), 호이스팅할 때 선언부만 올라가지 대입한 값은 올라가지 않음
// var a = 10; // 전역변수
// { 
//     console.log(`코드 블록 내부 a : ${a}`); // 출력 : 10
//     console.log(`코드 블록 내부 b : ${b}`); // 출력 : undefined
//     var b = 20; // 호이스팅되어 올라감(선언부만 올라가고 대입한 값은 올라가지 않음)
// }
// console.log(`코드 블록 외부 a : ${a}`); // 출력 : 10
// console.log(`코드 블록 외부 b : ${b}`); // 출력 : 20


// 즉시 실행 함수 : 존재이유???, 한 번만 쓰고 버림(호출부가 없어도 호출이 됨!)
// 함수 표현식으로 익명의 함수 만들기
// const init = function() {
//     console.log("initialize !!!!");
// }
// init();
// (function init(){
//     console.log("initialize !!!"); 
// })();


// Callback 함수 : 파라미터로 함수를 전달받아서 함수의 내부에서 실행하는 함수
// 자바스크립트에서 전통적인 비동기적 메커니즘을 지원
// 자바스크립트는 싱글쓰레드 언어이기 때문에 쓰레드가 Blocking되는 현상을 막고 Non-blocking되도록 함(콜백함수 사용)
// 비동기 : 블록킹(처리가 오래걸려 중단되는 것)을 방지하여 싱글쓰레드가 논블로킹으로 동작되도록 함
// 비동기적 테크닉 사용하는 경우 : 사용자의 이벤트 처리, 네트워크 응답 처리, 파일을 읽고 쓰는 동작, 의도적으로 시간 지연이 필요한 가능
function cry() {
    console.log("웁니다유ㅠㅠㅠ");
}
function sing() {
    console.log("노래를 부릅니당");
}
function dance() {
    console.log("춤을 춥니당");
}
function checkMood(mood) {
    if(mood === "good") sing();
    else cry();
}
function checkMoodCallback(mood, goodCall, badCall) {
    if (mood === "good") goodCall();
    else badCall();
}
// 기분이 좋을 때는 춤을추고 기분이 안좋으면 노래를 불러~~~~
checkMoodCallback("good", dance, sing); // 출력 : 춤을 춥니당
checkMoodCallback("bad", dance, sing); // 출력 : 노래를 부릅니당

function 상품구매(품목, 가격, 수량, callback) {
    console.log(품목 + "상품을 " + 수량 + " 개 구매하였습니다.");
    setTimeout(function() {
        console.log("계산이 필요합니다.");
        let 전체금액 = 가격 * 수량;
        callback(전체금액);
    }, 2000); // 2초 이후에 함수를 불러주는 것, setTimeout(함수, 시간)이용!
}
function 지불금액(금액) {
    console.log("지불할 금액은 : " + 금액 + "입니다.");
}
상품구매("호박고구마", 1000, 5, 지불금액);
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 기본값 할당함
function sum1(a=10, b=20) {
    console.log(a+b);
}
sum1(); // 30
sum1(100); // 120 (a값이 100, b값이 없으니까 default 20으로 들어옴)
sum1(100, 200); // 300

// 기본값 할당하지 않음
function sum2(a, b) {
    console.log(a+b);
}
sum2(); // NaN
sum2(100); // NaN
sum2(100, 200); // 300
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
